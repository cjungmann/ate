.TH ate 1 2023-06-26 "" "Loadable Bash Builtin Manual"
.de arg_handle
.   TP
.   I handle_name
The name of an initialized
.   B ate
handle
..
.de arg_return_value
.   TP
.   BI "-v " value_name
The name of the variable in which the result will be returned.
Without this option, the result will be returned in
.   BR ATE_VALUE .
..
.de arg_return_array
.   TP
.   BI "-a " array_name
The name of the array variable in which the result will be
returned.
Without this option, the result will be returned in
.   BR ATE_ARRAY .
..
.SH NAME
.B ate
\- Array Table Extension: use a Bash array as a table
.SH SYNOPSIS
.PP
.B ate
.I action_name handle_name
.RB [ "-a " "\fIarray_name\fP" ]
.RB [ "-v " "\fIvalue_name\fP" ]
.RI [ "extra ..." ]
.SH DESCRIPTION
.PP
Standard Bash arrays are one-dimensional and sequential (slow) access.
.B ate
manages an index to virtual row heads for a two-dimensional aspect
with fast random access.
.PP
Implemented as a builtin, it uses Bash primitive variables, it can
call Bash script functions, and it runs in the same process as the
shell script for improved performance.
.SH ENABLING ATE
.PP
The
.B ate
loadable builtin must be enabled before it can be used.
A script,
.BR enable_ate ,
is installed that provides the non-trivial arguments needed to enable
the builtin.
Enable the builtin with the following statement, in a shell, in a
.B ~/.bashrc
file, or in a script using
.BR ate :
.IP
.EX
enable $( enable_ate )
.EE
.PP
Without the
.B enable_ate
script, the syntax to enable a loadable builtin is:
.IP
.EX
enable -f /path/to/ate.so ate
.EE
.SH ATE ACTIONS
.SS LIST_ACTIONS
.PP
Displays a list of all action names without explanation.
.PP
.B ate list_actions
.SS SHOW_ACTION
.PP
Show usage and short description for one or all actions.
.PP
.B ate show_action
.RI [ action_name ]
.RS 4
.TP
.I action_name
If used, this parameter will limit the usage display to the specified
action.
If this action is omitted, all actions will be displayed.
.RE
.SS DECLARE
.PP
Create and initialize an
.B ate
handle.
.PP
.B ate declare
.I handle_name
.RI  "[ " array_name " ] [ " row_size " ]"
.RS 4
.TP
.I handle_name
The
.I handle_name
will be used to create a new Bash
.B ate
handle variable.
.TP
.I array_name
Name of the hosted array.
The array will be created if it doesn't already exist.
An array with a generated name will be created if this argument
is omitted.
.TP
.I row_size
The number of array elements in a table row.
The
.I row_size
will be set to 1 if
.I row_size
is not specified.
.RE
.SS APPEND_DATA
.PP
Use this action to add rows to the table.
If the number of
.I values
is not evenly-divisible by
.BR row_size ,
the incomplete row will not be added to the table.
.PP
After using this action, the row index will be out-of-date, meaning
that the new rows are not immediately available.  Be sure to invoke
action
.B update_index
when finished appending data to access the new rows.
.PP
.B ate append_data
.I handle_name
.RI "[ " "value ..." " ]"
.RS 4
.arg_handle
.TP
.RI "[ " "value ..." " ]"
The values to be appended to the hosted array.
.RE
.SS UPDATE_INDEX
.PP
Generates an index into the elements of the hosted array,
one index for each row head.
The
.BR get_row " and " put_row
actions rely on the index being up-to-date.
.PP
.B ate update_index
.I handle_name
.RS 4
.arg_handle
The name of an initialized handle variable
.RE
.SS GET_ROW_COUNT
.PP
Get the number of indexed rows in the table.
.PP
.B ate get_row_count
.I handle_name
.RB [ " -v \fIvalue_name\fP " ]
.RS 4
.arg_handle
.arg_return_value
.RE
.SS GET_ROW_SIZE
.PP
Returns the number of fields in a row.
This value is defined with the
.B declare
action when the handle is initialized.
.PP
.B ate get_row_size
.I handle_name
.RB [ " -v \fIvalue_name\fP " ]
.RS 4
.arg_handle
.arg_return_value
.RE
.SS GET_ARRAY_NAME
.PP
This action returns the name of the array on which the table is
based.
If an array name is not specified during the
.B declare
action, this action is how one learns the name of the hosted array.
.PP
.B ate get_array_name
.I handle_name
.RB [ " -v \fIvalue_name\fP " ]
.RS 4
.arg_handle
.arg_return_value
.RE
.SS GET_ROW
.PP
Read the contents of a virtual row into an array
.PP
.B ate get_row
.I handle_name
.I row_index
.RB [ " -a \fIarray_name\fP " ]
.RS 4
.arg_handle
.TP
.I row_index
is the row number that should be retrieved.  The index value is
zero-based, that is a row index of 0 \(sq0\(sq returns the first
record.
.arg_return_array
.RE
.SS PUT_ROW
.PP
Updates a table row with the contents of a source array.
Presumably, the source comes from a previous
.B get_row
action.
The
.I array_name
is a required argument.
.PP
Exactly
.B row_size
elements will be copied.
Extra source elements will be ignored, and blank values will be
saved to the elements of the target array for any missing source
elements.
.PP
Typically, one retrieves a row with the
.B get_row
action, makes changes to the returned row, then calls
.B put_row
to update the record.
.PP
This action will not add new rows, use the
.B append_data
action to add rows to the table.
.PP
.B ate put_row
.I handle_name row_index array_name
.RS 4
.arg_handle
.TP
.I row_index
is the 0-based row number to which the contents of
.I array_name
will be copied.
The
.I row_index
value must from 0 to
.I row_count
- 1.
.TP
.I array_name
required name of the array with the values that should replace
the values of the row indicated by
.IR row_index .
.RE
.SS GET_FIELD_SIZES
.PP
Returns an array whose elements contain the length of the longest
string for each field in the table.
Use these numbers to inform formatting of the table on a printout.
.PP
.B
ate get_field_sizes
.I handle_name
.RB "[ " "-a \fIarrayname\fP" " ]"
.RS 4
.arg_handle
.arg_return_array
.RE
.SS WALK_ROWS
.PP
Invokes a callback function with the row index and contents of the
rows in the table, optionally limited by arguments
.IR starting_row " and " row_count .
.PP
The callback function will be given two arguments, the
row number and the name of the array containing the row values.
.PP
If the callback function returns 0, the next row will be sent.
If the callback function return non-0 (for now), the row walk
will be terminated.
.PP
.B ate walk_rows
.I handle_name callback_name
.RI "[ " starting_row " ] [ " row_count " ]"
.RS 4
.arg_handle
.TP
.I callback_name
to a function that
.B ate
will call with each indexed table row.
.TP
.I starting_row
If specified, this is the (0-based) row number of the first
row to be sent to the callback function.
.TP
.I row_count
If specified (following the
.IR starting_row ),
this is the number of rows to send to the callback function.
.PP
Example:
.PP
.EX
display_row()
{
   local -i row_num=\(dq$1\(dq
   local -n row_array=\(dq$2\(dq

   printf "%2d) %s\n" "$row_num" "${row_array[*]}"
   return 0
}

ate walk_rows handle display_row
.EE
.RE
.SH EXAMPLE
.PP
.EX
declare -a rowdata=(
   Mom     45
   Dad     48
   Sister  21
   Brother 18
)
# Create the handle
if ate \fBdeclare\fP handle 2; then

   # Add data to the handle
   ate \fBappend_data\fP handle \(dq${rowdata[@]}\(dq

   # Read a row from the handle
   ate \fBget_row\fP handle 1
   echo "${ATE_ARRAY[0]} is ${ATE_ARRAY[1]} years old"

   # Read another row, saving to a non-default variable
   ate \fBget_row\fP handle -a recarr 2
   echo "${recarr[0]} is ${recarr[1]} years old"

   # Update the record and write back to the table
   echo "It's ${recarr[0]}'s birthday, update their age."
   (( ++recarr[1] ))
   ate \fBput_row\fP handle 2 recarr
fi
.EE


.SH WARNINGS
.TP
.B Hosted Array
Do not attempt to manipulate the ate-hosted array without the
.B ate
handle.
Directly adding or removing elements from the hosted array will
cause the index to be out-of-date.
Additionally, if added or removed elements result in an uneven
number of elements (not evenly-divisible into the row_size),
some data will not be accessible from
.BR ate.
