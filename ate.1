.TH ate 1 2023-06-26 "" "Loadable Bash Builtin Manual"
.de arg_handle
.   TP
.   I handle_name
the name of an initialized
.   B ate
handle
..
.de arg_return_value
.   TP
.   BI "-v " value_name
the name of the variable in which the result will be returned.
Without this option, the result will be returned in
.   BR ATE_VALUE .
..
.de arg_return_array
.   TP
.   BI "-a " array_name
the name of the array variable in which the result will be
returned.
Without this option, the result will be returned in
.   BR ATE_ARRAY .
..
.SH NAME
.B ate
\- Array Table Extension: use a Bash array as a table
.SH SYNOPSIS
.PP
.B ate
.I action_name handle_name
.RB [ "-a " "\fIarray_name\fP" ]
.RB [ "-v " "\fIvalue_name\fP" ]
.RI [ "extra ..." ]
.SH DESCRIPTION
.PP
Standard Bash arrays are one-dimensional and sequential (slow) access.
.B ate
manages an index to virtual row heads for a two-dimensional aspect
with fast random access.
.PP
Implemented as a builtin, it uses Bash primitive variables, it can
call Bash script functions, and it runs in the same process as the
shell script for improved performance.
.SH ENABLING ATE
.PP
The
.B ate
loadable builtin must be enabled before it can be used.
A script,
.BR enable_ate ,
is installed that provides the non-trivial arguments needed to enable
the builtin.
Enable the builtin with the following statement, in a shell, in a
.B ~/.bashrc
file, or in a script using
.BR ate :
.IP
.EX
enable $( enable_ate )
.EE
.PP
Without the
.B enable_ate
script, the syntax to enable a loadable builtin is:
.IP
.EX
enable -f /path/to/ate.so ate
.EE
.SH RETURN VARIABLES
.PP
When an action returns information, the value is, by default, saved to
either
.BR ATE_VALUE " and " ATE_ARRAY
according to the return type.
This is done to avoid incurring the subprocess performance
penalty.
.PP
Alternate return variables can be specified with the
.BR -v " and " -a
options, which specify new names for the single and array return
variables.
.PP
In general, use the default return variable names if the value will
be used only once immediately after requesting the value.
Override the return variables if the return value will still be needed
after another action might overwrite the return value.
.PP
The
.B EXAMPLES
section below shows a variety of return variable manipulations.
.SH ATE ACTIONS
.SS LIST_ACTIONS
.PP
Displays a list of all action names without explanation.
.PP
.B ate list_actions
.SS SHOW_ACTION
.PP
Show usage and short description for one or all actions.
.PP
.B ate show_action
.RI [ action_name ]
.RS 4
.TP
.I action_name
If used, this parameter will limit the usage display to the specified
action.
If this action is omitted, all actions will be displayed.
.RE
.SS DECLARE
.PP
Create and initialize an
.B ate
handle.
.PP
.B ate declare
.I handle_name
.RI  "[ " array_name " ] [ " row_size " ]"
.RS 4
.TP
.I handle_name
The
.I handle_name
will be used to create a new Bash
.B ate
handle variable.
.TP
.I array_name
Name of the hosted array.
The array will be created if it doesn't already exist.
An array with a generated name will be created if this argument
is omitted.
.TP
.I row_size
The number of array elements in a table row.
The
.I row_size
will be set to 1 if
.I row_size
is not specified.
.RE
.PP
Refer to
.B DECLARE EXAMPLE
below.
.SS APPEND_DATA
.PP
Use this action to add rows to the table.
If the number of
.I values
is not evenly-divisible by
.BR row_size ,
the incomplete row will not be added to the table.
.PP
After using this action, the row index will be out-of-date, meaning
that the new rows are not immediately available.  Be sure to invoke
action
.B update_index
when finished appending data to access the new rows.
.PP
.B ate append_data
.I handle_name
.RI "[ " "value ..." " ]"
.RS 4
.arg_handle
.TP
.RI "[ " "value ..." " ]"
The values to be appended to the hosted array.
.RE
.PP
Refer to
.B DECLARE EXAMPLE
below.
.SS UPDATE_INDEX
.PP
Generates an index into the elements of the hosted array,
one index for each row head.
The
.BR get_row " and " put_row
actions rely on the index being up-to-date.
.PP
.B ate update_index
.I handle_name
.RS 4
.arg_handle
.RE
.PP
Refer to
.B DECLARE EXAMPLE
below.
.SS GET_ROW_COUNT
.PP
Get the number of indexed rows in the table.
.PP
.B ate get_row_count
.I handle_name
.RB [ " -v \fIvalue_name\fP " ]
.RS 4
.arg_handle
.arg_return_value
.RE
.PP
Refer to
.B GET INFO EXAMPLES
below.
.SS GET_ROW_SIZE
.PP
Returns the number of fields in a row.
This value is defined with the
.B declare
action when the handle is initialized.
.PP
.B ate get_row_size
.I handle_name
.RB [ " -v \fIvalue_name\fP " ]
.RS 4
.arg_handle
.arg_return_value
.RE
.PP
Refer to
.B GET INFO EXAMPLES
below.
.SS GET_ARRAY_NAME
.PP
This action returns the name of the array on which the table is
based.
If an array name is not specified during the
.B declare
action, this action is how one learns the name of the hosted array.
.PP
.B ate get_array_name
.I handle_name
.RB [ " -v \fIvalue_name\fP " ]
.RS 4
.arg_handle
.arg_return_value
.RE
.PP
Refer to
.B GET INFO EXAMPLES
below.
.SS GET_FIELD_SIZES
.PP
Returns an array whose elements contain the length of the longest
string for each field in the table.
Use these numbers to inform formatting of the table on a printout.
.PP
.B
ate get_field_sizes
.I handle_name
.RB "[ " "-a \fIarrayname\fP" " ]"
.RS 4
.arg_handle
.arg_return_array
.RE
.PP
Refer to
.B GET INFO EXAMPLES
for basic usage, and look at the
.B FORMATTED TABLE EXAMPLE
for a more advanced usage.
.SS GET_ROW
.PP
Read the contents of a virtual row into an array
.PP
.B ate get_row
.I handle_name
.I row_index
.RB [ " -a \fIarray_name\fP " ]
.RS 4
.arg_handle
.TP
.I row_index
is the row number that should be retrieved.  The index value is
zero-based, that is a row index of 0 \(aq0\(aq returns the first
record.
.arg_return_array
.RE
.PP
Refer to
.B GET_ROW EXMPLE
below.
.SS PUT_ROW
.PP
Updates a table row with the contents of a source array.
Presumably, the source comes from a previous
.B get_row
action.
The
.I array_name
is a required argument.
.PP
Exactly
.B row_size
elements will be copied.
Extra source elements will be ignored, and blank values will be
saved to the elements of the target array for any missing source
elements.
.PP
Typically, one retrieves a row with the
.B get_row
action, makes changes to the returned row, then calls
.B put_row
to update the record.
.PP
This action will not add new rows, use the
.B append_data
action to add rows to the table.
.PP
.B ate put_row
.I handle_name row_index array_name
.RS 4
.arg_handle
.TP
.I row_index
is the 0-based row number to which the contents of
.I array_name
will be copied.
The
.I row_index
value must from 0 to
.I row_count
- 1.
.TP
.I array_name
required name of the array with the values that should replace
the values of the row indicated by
.IR row_index .
.RE
.PP
Refer to
.B PUT_ROW EXMPLE
below.
.SS WALK_ROWS
.PP
Invokes a callback function with the row index and contents of the
rows in the table, optionally limited by arguments
.IR starting_row " and " row_count .
.PP
The callback function will be given two arguments, the
row number and the name of the array containing the row values.
.PP
If the callback function returns 0, the next row will be sent.
If the callback function return non-0 (for now), the row walk
will be terminated.
.PP
.B ate walk_rows
.I handle_name callback_name
.RI "[ " starting_row " ] [ " row_count " ]"
.RS 4
.arg_handle
.TP
.I callback_name
to a function that
.B ate
will call with each indexed table row.
.TP
.I starting_row
If specified, this is the (0-based) row number of the first
row to be sent to the callback function.
.TP
.I row_count
If specified (following the
.IR starting_row ),
this is the number of rows to send to the callback function.
.RE
.PP
Refer to
.BR "WALK_ROWS EXAMPLE " and " FORMATTED TABLE EXAMPLE"
below.
.SS SORT
.PP
Create a duplicate table handle with the rows sorted based
on the order imposed by a callback function.
This action exposes the C-library
.B qsort
function for use in a Bash script.
.PP
.B ate sort
.I handle_name sort_function sorted_handle_name
.RS 4
.arg_handle
.TP
.I sort_function
the name of a script callback function that will report the
relative order of two given rows
.TP
.I sorted_handle_name
the requested name for the new sorted handle
.RE
.PP
The
.I sort_function
will get three SHELL_VAR names, the first of the variable in
which the comparison result will be returned, the second is the
left-hand row, and the third argument is the name of the right-hand
row.
.PP
The three arguments should be assigned to
.B name_ref
variables.
.PP
Refer to
.B SORT EXAMPLE
below.
.SH EXAMPLES
.PP
A picture is worth a thousand words, likewise, an example may be more
useful than pages of documentation.
.SS DECLARE EXAMPLE
.PP
An
.B ate
handle begins with an array.
There are two methods:
.IP
.EX
declare -a pets=(
   dog bark
   cat meow
   goat bleat
   duck quack
   cow moo

// Method 1, use existing array
ate \fBdeclare\fP pet_handle 2 pets

// Method 2, using anonymous array, filled in second step
ate \fBdeclare\fP pet_handle 2
ate \fBappend_data\fP pet_handle \(dq${pets[@]}\(dq

# Must manually update index after \fBappend_data\fP
ate \fBupdate_index\fP pet_handle
.EE
.SS GET INFO EXAMPLES
.PP
There are some informational actions, as shown:
.IP
.EX
ate \fBget_array_name\fP pet_handle
echo \(dqArray name is $ATE_VALUE\(dq

ate \fBget_row_count\fP pet_handle -v row_count
echo \(dqRow count is $row_count\(dq

ate \fBget_row_size\fP pet_handle -v row_size
echo \(dqRow size is $row_size\(dq

ate \fBget_field_sizes\fP pet_handle -a col_sizes
echo \(dqField sizes are ${col_sizes[*]}\(dq
.EE
.SS GET_ROW EXAMPLE
.PP
Access a table row by 0-based index.
Since the return value is an array, use
.B -a
to specify a result variable name.
.IP
.EX
ate \fBget_row\fP pet_handle 0
echo \(dqfirst row is ${ATE_ARRAY[*]}\(dq
ate \fBget_row\fP pet_handle 1 -a pet_row
echo \(dqsecond row is ${pet_row[*]}\(dq
.EE
.SS PUT_ROW EXAMPLE
.PP
The script must take care to keep the row and its row number
in sync.
.IP
.EX
declare -i dog_row=0
ate \fBget_row\fP pet_handle \(dq$dog_row\(dq -a pet_row

# change second column and update table
pet_row[1]="bow-wow"
ate \fBput_row\fP pet_handle \(dq$dog_row\(dq pet_row
.EE
.SS WALK_ROWS EXAMPLE
.PP
The
.B walk_rows
action invokes a callback function for each row:
.IP
.EX
display_row()
{
   local -i row_num=\(dq$1\(dq
   # try to avoid name collisions with nameref variables:
   local -n ur_row=\(dq$2\(dq

   printf \(dq%s makes a %s\(rsn\(dq \(dq${ur_row[*]}\(dq

   # Return 0 to continue, non-zero to terminate row walk:
   return 0
}

ate \fBwalk_rows\fP pet_handle display_row
.EE
.SS SORT EXAMPLE
.PP
Like
.BR walk_rows ", the " sort " action"
employes a callback function for flexible ordering:
.IP
.EX
compare_names()
{
   local -n cr_result=\(dq$1\(dq
   local -n cr_left=\(dq$2\(dq
   local -n cr_right=\(dq$3\(dq

   # isolate thd column on which we're sorting
   local name_left=\(dq${cr_left[0]}\(dq
   local name_right=\(dq${cr_right[0]}\(dq

   if [[ \(dq$left\(dq < \(dq$right\(dq ]]; then
      cr_result=-1
   elif [[ \(dq$right\(dq < \(dq$left\(dq ]]; then
      cr_result=1
   else
      cr_result=0
   fi

   return 0
}

# Create (and use) sorted handle:
ate \fBsort\fP pet_handle compare_names pets_by_name
ate \fBwalk_rows\fP pets_by_name display_row
.EE
.SS FORMATTED TABLE EXAMPLE
.PP
Tables with aligned columns are easier to read.
Use
.B ate
actions
.BR get_field_sizes " and " walk_rows
to produce an aligned-column table display by constructing
a custom
.B printf
format string based on the maximum string lengths of each field.
.IP
.EX
make_format_string()
{
   local -n mfs_string=\(dq$1\(dq
   local -n mfs_colsizes=\(dq$2\(dq

   local -a fs_parts=()
   local delim=\(dq\(dq
   local -i width
   for width in \(dq${mfs_widths[@]}\(dq; do
       fs_parts+=( \(dq$delim\(dq \(dq%-${width}s\(dq )
       delim=\(dq \(dq
   done

   local IFS=$\(aq\(aq
   mfs_string=\(dq${fs_parts[*]}\(rsn\(dq
}

ate \fBget_field_sizes\fP pet_handle
declare format_str

# Passing name, not value of ATE_ARRAY variable,
# don't add the \(aq$\(aq prefix:
make_format_string \(dqformat_str\(dq \(dqATE_ARRAY\(dq

# Use the format string to display rows:
display_with_format_string()
{
   local -n fwfs_row=\(dq$2\(dq
   printf \(dq$format_str\(dq \(dq${fwfs_row[@]}\(dq
}
ate \fBwalk_rows\fP pet_handle display_with_format_string
.EE

.SH WARNINGS
.TP
.B Hosted Array
Do not attempt to manipulate the ate-hosted array without the
.B ate
handle.
Directly adding or removing elements from the hosted array will
cause the index to be out-of-date.
Additionally, if added or removed elements result in an uneven
number of elements (not evenly-divisible into the row_size),
some data will not be accessible from
.BR ate.
