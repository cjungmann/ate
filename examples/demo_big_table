#!/usr/bin/env bash

if ! enable -f ../ate.so ate; then
    echo "Failed to enable ate module."
    exit 1
fi

# Include this for convient printing
source print_formatted_table_with_nulls

# SOURCE FOR THIS DATA, download basic data:
declare data_source_url="https://simplemaps.com/data/us-counties"

# alternate source, more fields, includes coordinates, missing population data:
# https://public.opendatasoft.com/explore/dataset/georef-united-states-of-america-county/table/?disjunctive.ste_code&disjunctive.ste_name&disjunctive.coty_code&disjunctive.coty_name&sort=year

#
# After a consent message, this function downloads and extracts
# the data file used by the table-building part of the script.
#
# Any failure will show an error message and abort the script.
#
prepare_data_source()
{
    local csvfile="uscounties.csv"

    cat <<EOF
To continue with this script, you will need to download data
and extract a file ($csvfile) from a public site,
'$data_source_url'.

This is only required when the $csvfile file is not found.
If you consent to and successfully download and extract the file,
the program will proceed.  If the script is run again, it will
skip this message unless the file was deleted or otherwise missing.

Running 'make clean' in the project's root directory will delete
the downloaded files.

EOF

    read -n1 -p "Press 'y' to consent to download, any other key to abort"
    if ! [[ "${REPLY,,}" == 'y' ]]; then
        echo
        exit 1
    fi

    local url_root="${data_source_url%%/data*}"
    local data_url

    # Download webpage and extract database location
    local data_file
    local retarget=href=\"\([^\"]+\\.zip\)\"
    while read -r; do
        if [[ "$REPLY" =~ $retarget ]]; then
            data_url="${url_root}${BASH_REMATCH[1]}"
            break
        fi
    done < <( wget -q -O- "$data_source_url" )

    if [ -n "$data_url" ]; then
        echo "Found the URL: '$data_url'"
        data_file="${data_url##*/}"
        echo "About to attempt downloading '$data_url' to $data_file"
        if wget -q "$data_url" -O "$data_file"; then
            if unzip "$data_file" "$csvfile"; then
                echo "The '$csvfile' is now available."
                read -n1 -p "Press any key to continue the script."
            else
                echo "Failed to extract '$csvfile'"
            fi
        else
            echo "Failed to download the '$data_file' from '$data_source_url'"
        fi
    else
        echo "Failed to find data source URL from the '$data_source_url'."
    fi

    exit 1
}

exit_on_error()
{
    local -i ecode="$1"
    if [ "$ecode" -ne 0 ]; then
        printf $'Error code \e[31;1m%d\e[m, \e[32;1m%s\e[m.\n' "$ecode" "$ATE_ERROR"
        exit 1
    fi
}

declare unparan_re=^\"\([^\"]+\)\"
unparenthesize()
{
    local -n u_array="$1"
    local -a arrcopy=( "${u_array[@]}" )
    u_array=()
    local el
    for el in "${arrcopy[@]}"; do
        if [[ "$el" =~ $unparan_re ]]; then
            u_array+=( "${BASH_REMATCH[1]}" )
        else
            u_array+=( "ERROR" )
        fi
    done
}

fill_table()
{
    local handle_name="$1"

    local source_name="uscounties.csv"
    if ! [ -e "$source_name" ]; then
        prepare_data_source
    fi

    local OIFS="$IFS"
    local IFS=','

    local -a temp_array
    local -i count=0
    while read -r -a cty; do
        unparenthesize "cty"
        temp_array=( $(( count++ ))  "${cty[1]}" "${cty[4]}" "${cty[5]}" "${cty[3]}" "${cty[8]}" )
        ate append_data "$handle_name" "${temp_array[@]}"
    done < "$source_name"

    ate index_rows "$handle_name"
    exit_on_error "$?"
}

set_key_name()
{
    local -n skn_return="$1"
    local -n skn_row="$2"
    skn_return="${skn_row[1]}"
    return 0
}


ate declare "counties_handle" 6
exit_on_error "$?"

fill_table "counties_handle"

# print_formatted_table_with_nulls "counties_handle"

ate make_key "counties_handle" set_key_name "key_county_names"
exit_on_error "$?"

print_formatted_table_with_nulls "key_county_names"
