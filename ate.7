.TH ate 7 2023-07-04 "" "Miscellaneous Information Manual"
\" Print ate command parameters aligned on horizontal position
\" of the previous output line.
.de ate_args
.  nr lll \\n[.n]
.  sp -1
.  in +\\n[lll]u
 \fB\\$1\\fP \\c
.  shift
.  while \\n(.$>0 \{\
.    ds arg \\$1
.    ds char_one \\$1
.    substring char_one 0 0
.    ie "\\*[char_one]"-" \{ \\c " (align the quote marks for the editor)
\\fB\\*[arg]\fP \\c
.    \}
.    el \\*[arg] \\c
.  shift
.  \}
.  in
.  br
..
\" Simple implementation of complete ate command call, using
.\" the .ate_args macro to complete the statement.
.de invoke_ate
ate
.br
.  ate_args \\$^
..
.SH NAME
.B ate
\- Tutorial for ate Builtin Command
.SH SYNOPSIS
.PP
.EX
ate \c
.I action_name \c
.RI [ handle_name ] \c
.RI [ "\fB-a\fP array_name" ] \c
.RI [ "\fB-v\fP value_name" "] ..."
.SH DESCRIPTION
.PP
The name
.B ate
stands for
.IR "Array Table Extension" .
The
.B ate
command exposes an API (Application Programming Interface) for
manipulating a Bash array as a table.
.PP
Once a script declares sn
.B ate
handle, the handle can then be used to add rows, read or write
specific rows, change the row size, sort, filter, and create and
search a keyed index for sequential access by a user-defined key.
.SS ARRAY AS TABLE
.PP
The following two statements declare the same two-column table
of pet information.
The second statement organizes the elements to look like the table
they represent.
.IP
.EX
# Declare a pet table with animal names and the sound they make.

# flat table declaration
declare -a pets=( dog bark cat meow parrot squawk pig oink )

# shaped table declaration
declare -a pets=(
   dog    bark
   cat    meow
   parrot squawk
   pig    oink
)
.EE
.PP
Whichever format is used to declare the array, it is important that
the array data is aligned according to the table dimensions.
Missing or empty row values must have an empty string value to
align the data of the following rows.




.SH ATE BASICS
.PP
A valid
.B ate
command is followed arguments that must follow a defined order, and
options that may come in any order or position after the
.B ate
command.
.SS OPTIONS
.PP
In an
.B ate
command, arguments that begin with a dash and a letter and may or may
not be followed by the option's value.
For options that take a value, the space between the option letter and the
option value is optional.
For example,
.BI -v " row_size"
and
.BI -v row_size
are equivalent.
.TP
.B Special options -a \fIarray_name\fP and -v \fIvalue_name\fP
For actions that produce readable results, the options
.BR -a " and " -v
tell
.B ate
what names to use for reporting array and value results respectively.
.IP
.BI -v " value_name"
is recognized by actions
.BR get_row_count ", " get_row_size ", " get_row_count ", and " seek_key,
which all return a single value in a shell variable named after
.I value_name
or
.B ATE_VALUE
if the
.B -v
option was not specified.
.IP
.BI -a " array_name"
is recognized by actions
.BR get_field_sizes ", and " get_row,
which return the action results in an array shell variable named after the
.B -a
option or
.B ATE_ARRAY
if the
.B -a
options was not specified.
.PP
Other options may be available for specific actions.
Refer to
.BR ate (1).
.SS ARGUMENTS
.PP
Arguments that are not options must be submitted to the
.B ate
command in the expected order after the options are removed from
the commandline.
.PP
The first argument is always the
.IR action_name .
With the exceptions of help actions
.BR list_actions " and " show_action ,
the second argument is always a
.IR handle_name .
Other arguments may follow according to the needs of the
.IR action_name .
.PP
Let's illustrate the syntax with a simple example where a handle is
created and the second field of the dog row is changed from a verb to
a sound.
.IP
.EX
.invoke_ate declare pet_handle 2 pets
.invoke_ate get_row pet_handle 0
ATE_ARRAY[1]=\(dqwoof\(dq
.invoke_ate put_row pet_handle 0 ATE_ARRAY
.EE

.SH THE TABLE ARRAY
.PP
A Bash array is at the heart of the
.B ate
handle.
The Bash array must organize its data into repeated sequences of
values that correspond to rows and columns.
.SS THE KEY FIELD
Throughout the
.B ate
documentation, the first element of each row (index 0)  will be
referred to as the
.B key
field or element.
The key field anchors each row and is the unstated focus of several
.B ate
actions.
.PP
The following simple array, which will be used throughout this
tutorial, illustrates how the array elements should be organized.
The key field is an animal name and the second field is the sound the
animal makes.
.PP
.RS 4
.EX
declare -a pets=(
   dog    bark
   cat    meow
   parrot squawk
   pig    oink
)
.EE
.RE
.PP
The pets array describes a 2-column table with 4 rows.
In this case the array's initialization data is visually organized
into rows and columns, but this kind of organization is not
necessary.
Some sources of data are linear, but can still be organized into
tables.
For example, a table could be constructed from the default
.I git log
output, which lists entries in groups of 6 lines each.
.SS 0-BASED INDEX NUMBERING
.PP
In Bash and many other languages, the index of the first element of
an array is 0, and we use the same convention with
.BR ate .
.PP
The first row in a table is row index 0, the first element of a row
(the key field) is also index 0.
.SH CREATE AN ATE HANDLE
.SS DIRECT-DATA METHOD
.PP
Initialize a new
.B ate
handle with our pet array:
.IP
.EX
.invoke_ate declare pet_handle 2 pets
.EE
.PP
where
.I pet_handle
is the requested name for the new handle,
.I 2
is the number of elements in a row, and
.I pets
is the name of the array to be attached to the handle.
.RE
.SS DEFERRED-DATA METHOD
.PP
When a source array is not specified in the
.B ate declare
action,
.B ate
will create an empty array with a unique name for its use.
The data for the table must be introduced later.
The following examples will show three methods of populating the
table with data.
.PP
Pay attention to the notes following the examples.
.TP 4
.B Deferred-data Declare Example 1
Using
.B append_data
action to Load data from the pets array:
.IP
.EX
.invoke_ate declare pet_handle 3

.invoke_ate append_data pet_handle "${pets[@]}"

.invoke_ate index_rows pet_handle
.EE
.TP 4
.B Deferred-data Declare Example 2
Use the
.B append_data
action with output from a formatted data file:
.IP
.EX
.invoke_ate declare mods_handle 6

while read -r; do
   ate
.ate_args append_data mods_handle $REPLY
done < <( cat /proc/modules )

.invoke_ate index_rows mods_handle
.EE
.TP 4
.B Deferred-data Declare Example 2
Use the
.B get_array_name
action to load data directly into the array:
.IP
.EX
.invoke_ate declare pet_handle 2
.invoke_ate get_array_name pet_handle -v array_name

declare -n tarray=\(dq\(Doarray_name\(dq
tarray+=( \(dq\(Do{pets[@]}\(dq )

.invoke_ate index_rows pet_handle
.EE
.TP
.B DEFERRED-DATA NOTES:
.RS 4
.TP 4
.B Index rows after adding data
Any time data is added to the table, either through the
.B append_data
action or directly into the hosted array, the keys index must
be regenerated with the
.B index_rows
action  before the new rows will be available.
.TP 4
.B APPEND_DATA only saves data row-size multiples
The
.B append_data
action does not save incomplete rows.
For example, when loading five new data members to a three-element
row size table, the first three elements would be added, but the
remaining two elements would be discarded because they would be an
incomplete row.
.RE
.SH TABLE INFORMATION
.PP
There are four informational actions,
.BR get_row_size ", " get_row_count ", " get_array_name ", and " get_field_sizes .
.IP
.EX
.invoke_ate declare pet_handle 2 pets
.invoke_ate get_row_size pet_handle -v row_size
.invoke_ate get_row_count pet_handle -v row_count
.invoke_ate get_array_name pet_handle -v array_name
.invoie_ate get_field_sizes pet_handle -a field_sizes

declare -a pfargs=(
   \(dqThe pet_handle uses array %s for a table of %d rows of %d field\n\(dq
   \(dq\(Doarray_name\(dq
   \(dq\(Dorow_count\(dq
   \(dq\(Dorow_size\(dq
)

printf \(dq\(Do{pfargs[@]}\(dq
printf \(dqThe field sizes are %d\n

.EE
